From 7a191e5191c8b813e929caedb3f3918bb08692a1 Mon Sep 17 00:00:00 2001
From: Alex Kube <alexander.j.kube@gmail.com>
Date: Wed, 23 Oct 2019 21:18:12 +0430
Subject: [PATCH 5/9] cmd/dist: separate host and target builds

Upstream-Status: Inappropriate [OE specific]

Change the dist tool to allow for OE-style cross-
and cross-canadian builds:

 - command flags --host-only and --target only are added;
   if one is present, the other changes mentioned below
   take effect, and arguments may also be specified on
   the command line to enumerate the package(s) to be
   built.

 - for OE cross builds, go_bootstrap is always built for
   the current build host, and is moved, along with the supporting
   toolchain (asm, compile, etc.) to a separate 'native_native'
   directory under GOROOT/pkg/tool.

 - go_bootstrap is not automatically removed after the build,
   so it can be reused later (e.g., building both static and
   shared runtime).

Note that for --host-only builds, it would be nice to specify
just the "cmd" package to build only the go commands/tools,
the staleness checks in the dist tool will fail if the "std"
library has not also been built.  So host-only builds have to
build everything anyway.

Adapted to Go 1.13 from patches originally submitted to
the meta/recipes-devtools/go tree by
Matt Madison <matt@madison.systems>.

Signed-off-by: Alexander J Kube <alexander.j.kube@gmail.com>
---
 src/cmd/dist/build.go | 152 +++++++++++++++++++++++++++++++-----------
 1 file changed, 113 insertions(+), 39 deletions(-)

--- a/src/cmd/dist/build.go
+++ b/src/cmd/dist/build.go
@@ -46,6 +46,7 @@ var (
 	goexperiment     string
 	workdir          string
 	tooldir          string
+	build_tooldir    string
 	oldgoos          string
 	oldgoarch        string
 	oldgocache       string
@@ -57,6 +58,7 @@ var (
 
 	rebuildall bool
 	noOpt      bool
+	crossBuild bool
 	isRelease  bool
 
 	vflag int // verbosity
@@ -263,6 +265,8 @@ func xinit() {
 		tooldir = pathf("%s/pkg/tool/%s_%s", goroot, gohostos, gohostarch)
 	}
 
+	build_tooldir = pathf("%s/pkg/tool/native_native", goroot)
+
 	goversion := findgoversion()
 	isRelease = strings.HasPrefix(goversion, "release.") || strings.HasPrefix(goversion, "go")
 }
@@ -498,9 +502,9 @@ func setup() {
 
 	goosGoarch := pathf("%s/pkg/%s_%s", goroot, gohostos, gohostarch)
 	if rebuildall {
-		xremoveall(goosGoarch)
+		xremoveall(build_tooldir)
 	}
-	xmkdirall(goosGoarch)
+	xmkdirall(build_tooldir)
 	xatexit(func() {
 		if files := xreaddir(goosGoarch); len(files) == 0 {
 			xremove(goosGoarch)
@@ -566,6 +570,8 @@ func setup() {
 			}
 		}
 	}
+
+	build_tooldir = pathf("%s/pkg/tool/native_native", goroot)
 }
 
 /*
@@ -1344,19 +1350,35 @@ func cmdbootstrap() {
 	defer timelog("end", "dist bootstrap")
 
 	var debug, distpack, force, noBanner, noClean bool
+	var hostOnly, targetOnly bool
+	var toBuild = []string{"std", "cmd"}
 	flag.BoolVar(&rebuildall, "a", rebuildall, "rebuild all")
 	flag.BoolVar(&debug, "d", debug, "enable debugging of bootstrap process")
 	flag.BoolVar(&distpack, "distpack", distpack, "write distribution files to pkg/distpack")
 	flag.BoolVar(&force, "force", force, "build even if the port is marked as broken")
 	flag.BoolVar(&noBanner, "no-banner", noBanner, "do not print banner")
 	flag.BoolVar(&noClean, "no-clean", noClean, "print deprecation warning")
+	flag.BoolVar(&hostOnly, "host-only", hostOnly, "build only host binaries, not target")
+	flag.BoolVar(&targetOnly, "target-only", targetOnly, "build only target binaries, not host")
 
-	xflagparse(0)
+	xflagparse(-1)
 
 	if noClean {
 		xprintf("warning: --no-clean is deprecated and has no effect; use 'go install std cmd' instead\n")
 	}
 
+	if hostOnly && targetOnly {
+		fatalf("specify only one of --host-only or --target-only\n")
+	}
+	crossBuild = hostOnly || targetOnly
+	if flag.NArg() > 0 {
+		if crossBuild {
+			toBuild = flag.Args()
+		} else {
+			fatalf("package names not permitted without --host-only or --target-only\n")
+		}
+	}
+
 	// Don't build broken ports by default.
 	if broken[goos+"/"+goarch] && !force {
 		fatalf("build stopped because the port %s/%s is marked as broken\n\n"+
@@ -1440,9 +1462,14 @@ func cmdbootstrap() {
 		xprintf("\n")
 	}
 
-	gogcflags = os.Getenv("GO_GCFLAGS") // we were using $BOOT_GO_GCFLAGS until now
-	setNoOpt()
-	goldflags = os.Getenv("GO_LDFLAGS") // we were using $BOOT_GO_LDFLAGS until now
+	// For split host/target cross/cross-canadian builds, we don't
+	// want to be setting these flags until after we have compiled
+	// the toolchain that runs on the build host.
+	if !crossBuild {
+		gogcflags = os.Getenv("GO_GCFLAGS") // we were using $BOOT_GO_GCFLAGS until now
+		setNoOpt()
+		goldflags = os.Getenv("GO_LDFLAGS") // we were using $BOOT_GO_LDFLAGS until now
+	}
 	goBootstrap := pathf("%s/go_bootstrap", tooldir)
 	if debug {
 		run("", ShowOutput|CheckExit, pathf("%s/compile", tooldir), "-V=full")
@@ -1470,7 +1497,11 @@ func cmdbootstrap() {
 		xprintf("\n")
 	}
 	xprintf("Building Go toolchain2 using go_bootstrap and Go toolchain1.\n")
-	os.Setenv("CC", compilerEnvLookup("CC", defaultcc, goos, goarch))
+	if crossBuild {
+		os.Setenv("CC", defaultcc[""])
+	} else {
+		os.Setenv("CC", compilerEnvLookup("CC", defaultcc, goos, goarch))
+	}
 	// Now that cmd/go is in charge of the build process, enable GOEXPERIMENT.
 	os.Setenv("GOEXPERIMENT", goexperiment)
 	// No need to enable PGO for toolchain2.
@@ -1523,48 +1554,83 @@ func cmdbootstrap() {
 		os.Setenv("GOCACHE", oldgocache)
 	}
 
-	if goos == oldgoos && goarch == oldgoarch {
-		// Common case - not setting up for cross-compilation.
-		timelog("build", "toolchain")
-		if vflag > 0 {
-			xprintf("\n")
+	if crossBuild {
+		gogcflags = os.Getenv("GO_GCFLAGS")
+		goldflags = os.Getenv("GO_LDFLAGS")
+		tool_files, _ := filepath.Glob(pathf("%s/*", tooldir))
+		for _, f := range tool_files {
+			copyfile(pathf("%s/%s", build_tooldir, filepath.Base(f)), f, writeExec)
+			xremove(f)
+		}
+		os.Setenv("GOTOOLDIR", build_tooldir)
+		goBootstrap = pathf("%s/go_bootstrap", build_tooldir)
+		if hostOnly {
+			timelog("build", "host toolchain")
+			if vflag > 0 {
+				xprintf("\n")
+			}
+			xprintf("Building %s for host, %s/%s.\n", strings.Join(toBuild, ","), goos, goarch)
+			goInstall(toolenv(), goBootstrap, toBuild...)
+			checkNotStale(toolenv(), goBootstrap, toBuild...)
+			// Skip cmdGo staleness checks here, since we can't necessarily run the cmdGo binary
+
+			timelog("build", "target toolchain")
+			if vflag > 0 {
+				xprintf("\n")
+			}
+		} else if targetOnly {
+			goos = oldgoos
+			goarch = oldgoarch
+			os.Setenv("GOOS", goos)
+			os.Setenv("GOARCH", goarch)
+			os.Setenv("CC", compilerEnvLookup("CC", defaultcc, goos, goarch))
+			xprintf("Building %s for target, %s/%s.\n", strings.Join(toBuild, ","), goos, goarch)
+			goInstall(toolenv(), goBootstrap, toBuild...)
+			checkNotStale(toolenv(), goBootstrap, toBuild...)
+			// Skip cmdGo staleness checks here, since we can't run the target's cmdGo binary
 		}
-		xprintf("Building packages and commands for %s/%s.\n", goos, goarch)
 	} else {
-		// GOOS/GOARCH does not match GOHOSTOS/GOHOSTARCH.
-		// Finish GOHOSTOS/GOHOSTARCH installation and then
-		// run GOOS/GOARCH installation.
-		timelog("build", "host toolchain")
-		if vflag > 0 {
-			xprintf("\n")
+
+		if goos == oldgoos && goarch == oldgoarch {
+			// Common case - not setting up for cross-compilation.
+			timelog("build", "toolchain")
+			if vflag > 0 {
+				xprintf("\n")
+			}
+			xprintf("Building packages and commands for %s/%s.\n", goos, goarch)
+		} else {
+			// GOOS/GOARCH does not match GOHOSTOS/GOHOSTARCH.
+			// Finish GOHOSTOS/GOHOSTARCH installation and then
+			// run GOOS/GOARCH installation.
+			timelog("build", "host toolchain")
+			if vflag > 0 {
+				xprintf("\n")
+			}
+			xprintf("Building packages and commands for host, %s/%s.\n", goos, goarch)
+			goInstall(toolenv(), goBootstrap, "std", "cmd")
+			checkNotStale(toolenv(), goBootstrap, "std", "cmd")
+
+			timelog("build", "target toolchain")
+			if vflag > 0 {
+				xprintf("\n")
+			}
+			goos = oldgoos
+			goarch = oldgoarch
+			os.Setenv("GOOS", goos)
+			os.Setenv("GOARCH", goarch)
+			os.Setenv("CC", compilerEnvLookup("CC", defaultcc, goos, goarch))
+			xprintf("Building packages and commands for target, %s/%s.\n", goos, goarch)
 		}
-		xprintf("Building commands for host, %s/%s.\n", goos, goarch)
 		goInstall(toolenv(), goBootstrap, "cmd")
 		checkNotStale(toolenv(), goBootstrap, "cmd")
 		checkNotStale(toolenv(), gorootBinGo, "cmd")
 
-		timelog("build", "target toolchain")
-		if vflag > 0 {
-			xprintf("\n")
-		}
-		goos = oldgoos
-		goarch = oldgoarch
-		os.Setenv("GOOS", goos)
-		os.Setenv("GOARCH", goarch)
-		os.Setenv("CC", compilerEnvLookup("CC", defaultcc, goos, goarch))
-		xprintf("Building packages and commands for target, %s/%s.\n", goos, goarch)
-	}
-	goInstall(nil, goBootstrap, "std")
-	goInstall(toolenv(), goBootstrap, "cmd")
-	checkNotStale(toolenv(), goBootstrap, toolchain...)
-	checkNotStale(nil, goBootstrap, "std")
-	checkNotStale(toolenv(), goBootstrap, "cmd")
-	checkNotStale(nil, gorootBinGo, "std")
-	checkNotStale(toolenv(), gorootBinGo, "cmd")
-	if debug {
-		run("", ShowOutput|CheckExit, pathf("%s/compile", tooldir), "-V=full")
-		checkNotStale(toolenv(), goBootstrap, toolchain...)
-		copyfile(pathf("%s/compile4", tooldir), pathf("%s/compile", tooldir), writeExec)
+		if debug {
+			run("", ShowOutput|CheckExit, pathf("%s/compile", tooldir), "-V=full")
+			run("", ShowOutput|CheckExit, pathf("%s/buildid", tooldir), pathf("%s/pkg/%s_%s/runtime/internal/sys.a", goroot, goos, goarch))
+			checkNotStale(toolenv(), goBootstrap, append(toolchain, "runtime/internal/sys")...)
+			copyfile(pathf("%s/compile4", tooldir), pathf("%s/compile", tooldir), writeExec)
+ 		}
 	}
 
 	// Check that there are no new files in $GOROOT/bin other than
@@ -1585,8 +1651,11 @@ func cmdbootstrap() {
 		}
 	}
 
-	// Remove go_bootstrap now that we're done.
-	xremove(pathf("%s/go_bootstrap"+exe, tooldir))
+	// Except that for split host/target cross-builds, we need to
+	// keep it.
+	if !crossBuild {
+		xremove(pathf("%s/go_bootstrap", tooldir))
+	}
 
 	if goos == "android" {
 		// Make sure the exec wrapper will sync a fresh $GOROOT to the device.
